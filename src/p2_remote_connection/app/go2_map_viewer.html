<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Go2 Map Viewer</title>

  <link rel="stylesheet" href="/app/static/shared.css" />
  <script src="/app/static/shared.js"></script>

  <style>
    /* Map-specific bits only (everything else comes from shared.css) */
    .mapPanel { margin-top: 12px; border: 1px solid var(--soft-border); border-radius: var(--radius); overflow: hidden; background:#fff; }
    .mapHeader { display:flex; justify-content: space-between; align-items:center; padding: 10px 12px; background: var(--soft-2); border-bottom:1px solid var(--soft-border); }
    .mapTitle { font-size:14px; font-weight:600; }
    .mapHint { color:#777; }
    .mapBox { padding: 12px; }
    .mapBox { padding: 12px; height: 72vh; min-height: 520px; } /* bigger map area */
    #mapCanvas {
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      width: 100%;
      height: 100%;                 /* fill mapBox */
      display: block;
      image-rendering: pixelated;
      background: #fff;
    }
    </style>

  <script>
    window.addEventListener("DOMContentLoaded", async () => {
      // Initialize shared behavior (auto defaultApi from UI host -> :8000)
      await Go2Shared.init({ defaultApi: "", showAuthButtons: true });

      // After init, if unlocked (auth disabled OR remembered token OK), start map
      setTimeout(refreshSafetyStatus, 200);
      setTimeout(() => startMapStreaming(true), 350);
    });
  </script>
</head>

<body>
  <!-- LOGIN OVERLAY (shared.css styles) -->
  <div id="loginOverlay" class="loginOverlay">
    <div class="loginCard">
      <h2>Connect to Go2</h2>
      <div class="loginForm">
        <input id="loginBaseUrl" placeholder="http://robot-ip:8000 or https://robot.domain" />
        <input id="loginToken" placeholder="Password" type="password" />

        <label style="display:flex; align-items:center; gap:8px; font-size:13px; color:#333;">
          <input id="showPw" type="checkbox" onclick="Go2Shared.togglePasswordVisibility()" />
          Show password
        </label>

        <button id="unlockBtn" onclick="Go2Shared.login()">Unlock</button>
        <div id="loginMsg" class="loginMsg"></div>
        <div class="loginTip">Tip: This password is unique per robot.</div>
      </div>
    </div>
  </div>

  <!-- MAIN APP -->
  <div id="appRoot">
      <div class="card">
      <h1>Unitree Go2 â€“ Map Viewer</h1>

      <div class="row">
        <input id="baseUrl" placeholder="http://<go2-ip>:8000" />
        <button onclick="Go2Shared.checkHealth()">Health</button>
        <button id="safetyToggleBtn" class="danger" onclick="toggleSafety()">STOP</button>
        <button onclick="Go2Shared.logout()">Logout</button>
      </div>

      <div class="small hint">
        UI host: <span id="uiHost" class="mono"></span><br/>
        API base: <span id="apiHost" class="mono"></span>
      </div>

      <div class="mapPanel">
        <div class="mapHeader">
          <div class="mapTitle">2D Map</div>
          <div class="mapHint small" id="mapHint">Idle</div>
        </div>
        <div class="mapBox">
          <canvas id="mapCanvas"></canvas>
        </div>
      </div>

      <div class="status">
        <div id="msg" class="small">Ready.</div>
        <div id="detail" class="mono"></div>
      </div>

      <div class="small" style="margin-top:10px;">
        STOP pauses map streaming (closes WS, stops HTTP fetch). RESUME reloads + continues.
      </div>
    </div>
  </div>

<script>
  // ----------------------------
  // STOP/RESUME latch (same idea as your other pages)
  // ----------------------------
  let stopLatched = false;
  let safetyBusy = false;

  function setMapHint(t) {
    const el = document.getElementById("mapHint");
    if (el) el.textContent = t;
  }

  function setSafetyButton(latched) {
    stopLatched = !!latched;
    const btn = document.getElementById("safetyToggleBtn");
    if (!btn) return;
    btn.textContent = stopLatched ? "RESUME" : "STOP";
    btn.classList.toggle("danger", !stopLatched);
    btn.disabled = safetyBusy;
  }

  async function refreshSafetyStatus() {
    if (!Go2Shared.ensureLoggedIn()) return;
    const r = await Go2Shared.httpGet("/safety/status", { bypassCommsGate: true });
    if (r.ok) {
      try {
        const data = JSON.parse(r.text);
        setSafetyButton(!!data.stop_latched);
        Go2Shared.state.COMMS_ENABLED = !stopLatched;
      } catch {}
    }
    return r;
  }

  async function toggleSafety() {
    if (!Go2Shared.ensureLoggedIn() || safetyBusy) return;
    safetyBusy = true;
    setSafetyButton(stopLatched);

    try {
      if (!stopLatched) {
        const r = await Go2Shared.httpPost("/safety/stop", null, { bypassCommsGate: true });
        if (!r.ok) { Go2Shared.setStatus(`STOP failed (HTTP ${r.status})`, false, `URL: ${r.url}\n${r.text}`); return; }
        Go2Shared.state.COMMS_ENABLED = false;
        setSafetyButton(true);
        stopMapStreaming();
        setMapHint("STOP latched: map paused");
        Go2Shared.setStatus("STOP latched ðŸ”’ (map paused)", true, `URL: ${r.url}\n${r.text}`);
      } else {
        const r2 = await Go2Shared.httpPost("/safety/resume", null, { bypassCommsGate: true });
        if (!r2.ok) { Go2Shared.setStatus(`RESUME failed (HTTP ${r2.status})`, false, `URL: ${r2.url}\n${r2.text}`); return; }
        Go2Shared.state.COMMS_ENABLED = true;
        setSafetyButton(false);
        setMapHint("Resuming map...");
        Go2Shared.setStatus("RESUME âœ… (map resumed)", true, `URL: ${r2.url}\n${r2.text}`);
        await startMapStreaming(true);
        await refreshSafetyStatus();
      }
    } finally {
      safetyBusy = false;
      setSafetyButton(stopLatched);
    }
  }

  // ----------------------------
  // Map viewer (OccupancyGrid full + update patches)
  // ----------------------------
  let canvas, ctx;

  let MAP_META = null;
  let MAP_GRID = null;   // Int8Array
  let IMG = null;        // ImageData at 1:1 map resolution
  let SCALE = 20;         // px per cell
  let MAP_WS = null;
  let pendingHeader = null;
  let keepaliveTimer = null;

  let OFF = null, OFF_CTX = null; // persistent offscreen
  let view = { scale: 3.0, ox: 0, oy: 0, dragging: false, lx: 0, ly: 0 };

  function resizeDisplayCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width));
    canvas.height = Math.max(1, Math.floor(rect.height));
    ctx.imageSmoothingEnabled = false;
  }

  function valToRGBA(v, out, idx) {
    // v is int8: -1, 0..100
    // Color plan:
    //  - unknown (-1): medium gray
    //  - free (0): near white
    //  - occupied (>= threshold): very dark
    //  - occupied (< threshold): dark gray ramp so even weak hits show
  
    const UNKNOWN = 170;      // gray
    const FREE = 245;         // near-white
    const OCC_DARK = 20;      // strong occupied
    const THRESH = 8;         // treat >=8 as occupied (tune 5..20)
  
    let r, g, b, a = 255;
  
    if (v === -1) {
      r = g = b = UNKNOWN;
    } else if (v === 0) {
      r = g = b = FREE;
    } else {
      const occ = Math.max(0, Math.min(100, v));
      if (occ >= THRESH) {
        // Make occupied pop hard
        r = g = b = OCC_DARK;
      } else {
        // Still visible for small values (darker than FREE)
        // occ in [1..THRESH-1] maps to [120..60] approx
        const t = occ / THRESH;
        const c = Math.round(120 - 60 * t);
        r = g = b = c;
      }
    }
  
    out[idx + 0] = r;
    out[idx + 1] = g;
    out[idx + 2] = b;
    out[idx + 3] = a;
  }

  async function gunzipToBytes(gzBytes) {
    const ds = new DecompressionStream("gzip");
    const blob = new Blob([gzBytes]);
    const stream = blob.stream().pipeThrough(ds);
    const ab = await new Response(stream).arrayBuffer();
    return new Uint8Array(ab);
  }

  function u8ToI8(u8) {
    return new Int8Array(u8.buffer, u8.byteOffset, u8.byteLength);
  }

  function ensureOffscreen(w, h) {
  if (OFF && OFF.width === w && OFF.height === h) return;

  OFF = new OffscreenCanvas(w, h);
  OFF_CTX = OFF.getContext("2d");
  OFF_CTX.imageSmoothingEnabled = false;

  // Reset view when map size changes
  view.scale = 1.5;
  view.ox = 0;
  view.oy = 0;
}

function resizeDisplayCanvas() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(1, Math.floor(rect.width));
  canvas.height = Math.max(1, Math.floor(rect.height));
  ctx.imageSmoothingEnabled = false;
}

function clampView() {
  if (!OFF) return;
  const vw = canvas.width / view.scale;
  const vh = canvas.height / view.scale;

  // Clamp panning to map bounds
  view.ox = Math.max(0, Math.min(OFF.width - vw, view.ox));
  view.oy = Math.max(0, Math.min(OFF.height - vh, view.oy));
}

function renderView() {
  if (!OFF) return;
  clampView();

  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const sx = view.ox;
  const sy = view.oy;
  const sw = canvas.width / view.scale;
  const sh = canvas.height / view.scale;

  ctx.drawImage(OFF, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
}

let panZoomInstalled = false;
function installPanZoom() {
  if (panZoomInstalled) return;
  panZoomInstalled = true;

  // Wheel zoom (zoom around cursor)
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    if (!OFF) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const worldX = view.ox + mx / view.scale;
    const worldY = view.oy + my / view.scale;

    const factor = (e.deltaY < 0) ? 1.15 : (1 / 1.15);
    const newScale = Math.max(0.5, Math.min(30, view.scale * factor));

    view.scale = newScale;
    view.ox = worldX - mx / view.scale;
    view.oy = worldY - my / view.scale;

    renderView();
  }, { passive: false });

  // Drag pan
  canvas.addEventListener("mousedown", (e) => {
    view.dragging = true;
    view.lx = e.clientX;
    view.ly = e.clientY;
  });

  window.addEventListener("mouseup", () => {
    view.dragging = false;
  });

  window.addEventListener("mousemove", (e) => {
    if (!view.dragging) return;
    const dx = e.clientX - view.lx;
    const dy = e.clientY - view.ly;
    view.lx = e.clientX;
    view.ly = e.clientY;

    view.ox -= dx / view.scale;
    view.oy -= dy / view.scale;
    renderView();
  });

  // Keep canvas matching container
  window.addEventListener("resize", () => {
    if (!canvas) return;
    resizeDisplayCanvas();
    renderView();
  });
}

  function drawFull() {
    if (!MAP_META || !MAP_GRID) return;
  
    const w = MAP_META.width, h = MAP_META.height;
    ensureOffscreen(w, h);
  
    // Build image once in memory (IMG is full map resolution)
    IMG = OFF_CTX.createImageData(w, h);
    const out = IMG.data;
  
    for (let i = 0; i < MAP_GRID.length; i++) {
      valToRGBA(MAP_GRID[i], out, i * 4);
    }
  
    // Store full raster into OFF for fast view rendering
    OFF_CTX.putImageData(IMG, 0, 0);
  
    // Display canvas matches panel size, and we render a viewport of OFF
    resizeDisplayCanvas();
    renderView();
  }

  function drawROI(x, y, w, h) {
    if (!IMG || !MAP_META || !MAP_GRID || !OFF_CTX) return;
  
    const out = IMG.data;
  
    for (let j = 0; j < h; j++) {
      for (let i = 0; i < w; i++) {
        const gx = x + i;
        const gy = y + j;
        const gidx = gy * MAP_META.width + gx;
        valToRGBA(MAP_GRID[gidx], out, gidx * 4);
      }
    }
  
    OFF_CTX.putImageData(IMG, 0, 0);
    renderView();
  }

  async function loadInitialMap() {
    // Use shared auth headers + base URL
    const url = Go2Shared.baseUrl() + "/map2d/full";
    const r = await fetch(url, { headers: Go2Shared.authHeaders() });

    if (r.status === 204) throw new Error("No map yet");
    if (!r.ok) throw new Error(`HTTP ${r.status}`);

    const width  = parseInt(r.headers.get("x-map-width"), 10);
    const height = parseInt(r.headers.get("x-map-height"), 10);

    if (!Number.isFinite(width) || !Number.isFinite(height)) {
      throw new Error(`Invalid map headers: width=${width}, height=${height}`);
    }

    // IMPORTANT: assign to global MAP_META (no shadowing)
    MAP_META = {
      frame_id: r.headers.get("x-map-frame") || "",
      resolution: parseFloat(r.headers.get("x-map-resolution") || "0.0"),
      width,
      height,
      origin_x: parseFloat(r.headers.get("x-map-origin-x") || "0.0"),
      origin_y: parseFloat(r.headers.get("x-map-origin-y") || "0.0"),
      seq: parseInt(r.headers.get("x-map-seq") || "0", 10),
    };

    const buf = new Uint8Array(await r.arrayBuffer());

    let rawU8;
    try { rawU8 = await gunzipToBytes(buf); }
    catch { rawU8 = buf; }

    MAP_GRID = u8ToI8(rawU8);

    if (MAP_GRID.length !== width * height) {
      throw new Error(`Bad map length: got ${MAP_GRID.length}, expected ${width * height}`);
    }

    drawFull();
  }

  function stopMapStreaming() {
    try { if (MAP_WS) MAP_WS.close(); } catch {}
    MAP_WS = null;
    pendingHeader = null;
    if (keepaliveTimer) { clearInterval(keepaliveTimer); keepaliveTimer = null; }
  }

  async function connectMapWS() {
    // Use shared WS base; include token only if auth enabled.
    let wsUrl = `${Go2Shared.apiWsBase()}/ws/map2d`;
    if (Go2Shared.cfg.authEnabled) {
      if (!Go2Shared.state.AUTH_TOKEN) throw new Error("Login required");
      wsUrl += `?token=${encodeURIComponent(Go2Shared.state.AUTH_TOKEN)}`;
    }

    MAP_WS = new WebSocket(wsUrl);
    MAP_WS.binaryType = "arraybuffer";

    MAP_WS.onopen = () => setMapHint("Map live âœ… (updates connected)");

    MAP_WS.onmessage = async (ev) => {
      if (!Go2Shared.state.COMMS_ENABLED || stopLatched) return;

      if (typeof ev.data === "string") {
        pendingHeader = JSON.parse(ev.data);
        return;
      }

      if (!pendingHeader) return;
      const h = pendingHeader;
      pendingHeader = null;

      const gz = new Uint8Array(ev.data);
      const rawU8 = await gunzipToBytes(gz);
      const rawI8 = u8ToI8(rawU8);

      if (h.t === "f") {
        MAP_META = { ...h.meta, seq: h.seq };
        MAP_GRID = rawI8;
        drawFull();
      } else if (h.t === "u") {
        if (!MAP_META || !MAP_GRID) return;

        const x = h.x|0, y = h.y|0, w = h.w|0, hh = h.h|0;

        let k = 0;
        for (let row = 0; row < hh; row++) {
          const dstStart = (y + row) * MAP_META.width + x;
          MAP_GRID.set(rawI8.subarray(k, k + w), dstStart);
          k += w;
        }

        drawROI(x, y, w, hh);
      }
    };

    MAP_WS.onclose = () => setMapHint((Go2Shared.state.COMMS_ENABLED && !stopLatched) ? "Map updates disconnected" : "Map paused");
    MAP_WS.onerror = () => setMapHint("Map WS error");

    // One keepalive timer per connection
    keepaliveTimer = setInterval(() => {
      if (MAP_WS && MAP_WS.readyState === WebSocket.OPEN) {
        try { MAP_WS.send("ping"); } catch {}
      }
    }, 10000);
  }

  async function startMapStreaming(forceReloadFull = false) {
    if (!Go2Shared.ensureLoggedIn()) return;

    // If STOP latched, pause
    if (!Go2Shared.state.COMMS_ENABLED || stopLatched) {
      setMapHint("STOP latched: map paused");
      return;
    }

    // Ensure canvas exists (after DOM)
    if (!canvas) {
      canvas = document.getElementById("mapCanvas");
      ctx = canvas.getContext("2d", { willReadFrequently: false });
      installPanZoom();
      resizeDisplayCanvas();
    }

    stopMapStreaming();
    setMapHint("Loading full map...");

    try {
      if (forceReloadFull || !MAP_META || !MAP_GRID) {
        await loadInitialMap();
      }
      await connectMapWS();
    } catch (e) {
      setMapHint("Map not available yet");
      Go2Shared.setStatus("Map load failed", false, String(e));
    }
  }
</script>
</body>
</html>
